// Generated by LiveScript 1.2.0
'use strict';
var Colors, DefaultOptions, _hasOwnProperty, _toString, isType, isString, isObject, isArray, JSONPrinter, toString$ = {}.toString, slice$ = [].slice;
Colors = {
  bold: ['\x1b[1m', '\x1b[22m'],
  italic: ['\x1b[3m', '\x1b[23m'],
  underline: ['\x1b[4m', '\x1b[24m'],
  inverse: ['\x1b[7m', '\x1b[27m'],
  white: ['\x1b[37m', '\x1b[39m'],
  grey: ['\x1b[90m', '\x1b[39m'],
  black: ['\x1b[30m', '\x1b[39m'],
  blue: ['\x1b[34m', '\x1b[39m'],
  cyan: ['\x1b[36m', '\x1b[39m'],
  green: ['\x1b[32m', '\x1b[39m'],
  magenta: ['\x1b[35m', '\x1b[39m'],
  red: ['\x1b[31m', '\x1b[39m'],
  yellow: ['\x1b[33m', '\x1b[39m']
};
DefaultOptions = {
  quote: '"',
  indent: '    ',
  quoteKeys: true,
  colors: false,
  collapseArray: true,
  commaFirst: false
};
_hasOwnProperty = Object.prototype.hasOwnProperty;
_toString = Object.prototype.toString;
isType = function(t, o){
  return t === _toString.call(o).slice(8, -1);
};
isString = function(it){
  return toString$.call(it).slice(8, -1) === 'String';
};
isObject = function(it){
  return toString$.call(it).slice(8, -1) === 'Object';
};
isArray = function(it){
  return toString$.call(it).slice(8, -1) === 'Array';
};
JSONPrinter = function(options){
  var defaults, print;
  defaults = import$(DefaultOptions, options);
  print = function(input, opts){
    var e, err, result, depth, iterate;
    if (!isType('Object', opts)) {
      opts = {};
    }
    opts = import$(defaults, opts);
    try {
      input = JSON.parse(input);
    } catch (e$) {
      e = e$;
      err = new Error('Failed to parse object: ' + e.message);
      err.stack = e.stack;
      throw err;
    }
    result = '';
    depth = 0;
    iterate = function(obj){
      var tabN, tabP, i, len, isAfterObject, isInsideArray, isArrayObject, writeDepth, k, val, ref$, isLeavingArray;
      tabN = '';
      tabP = '';
      i = 0;
      len = 0;
      isAfterObject = result[result.length - 2] === '}';
      isInsideArray = result[result.length - 1] === '[';
      isArrayObject = isArray(obj);
      writeDepth = ++depth;
      while (writeDepth--) {
        tabN += opts.indent;
      }
      tabP = tabN.replace(opts.indent, '');
      if (isInsideArray || isAfterObject) {
        result += '\n' + tabP;
      }
      result += isArrayObject ? '[' : '{';
      for (k in obj) {
        val = obj[k];
        if (opts.commaFirst) {
          if (!isArrayObject && opts.collapseArray) {
            result += '\n' + tabN;
          }
          if (len > 0) {
            result += ',';
          }
        } else {
          if (len > 0) {
            result += ',';
          }
          if (!isArrayObject && opts.collapseArray) {
            result += '\n' + tabN;
          }
        }
        len += 1;
        if (!isArrayObject) {
          result += opts.quoteKeys
            ? opts.quote + k + opts.quote + ': '
            : k + ': ';
        }
        switch (ref$ = [toString$.call(val).slice(8, -1)], false) {
        case !('Object' === ref$[0] || 'Array' === ref$[0]):
          iterate(val);
          break;
        case 'RegExp' !== ref$[0]:
          if (opts.colors) {
            result += Colors.yellow[0];
          }
          result += val;
          if (opts.colors) {
            result += Colors.yellow[1];
          }
          break;
        case 'Number' !== ref$[0]:
          if (opts.colors) {
            result += Colors.white[0];
          }
          result += val;
          if (opts.colors) {
            result += Colors.white[1];
          }
          break;
        case 'String' !== ref$[0]:
          if (opts.colors) {
            result += Colors.green[0];
          }
          result += opts.quote + val + opts.quote;
          if (opts.colors) {
            result += Colors.green[1];
          }
          break;
        case 'Boolean' !== ref$[0]:
          if (opts.colors) {
            result += Colors.blue[0];
          }
          result += val;
          if (opts.colors) {
            result += Colors.blue[1];
          }
        }
      }
      if (!isArrayObject || (isArrayObject && !opts.collapseArray)) {
        result += '\n' + tabP;
      }
      isLeavingArray = result[result.length - 1] === '}' && isArrayObject;
      if (isLeavingArray) {
        result += '\n' + tabP;
      }
      result += isArrayObject ? ']' : '}';
      depth -= 1;
      return result;
    };
    return iterate(input);
  };
  print.configure = function(conf){
    var key, value;
    for (key in conf) {
      value = conf[key];
      if (defaults.hasOwnProperty(key)) {
        defaults[key] = value;
      }
    }
    return this;
  };
  print.log = function(){
    var args, i$, len$, arg;
    args = slice$.call(arguments);
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      arg = args[i$];
      console.log(print(arg));
    }
    return this;
  };
  return print;
};
module.exports = JSONPrinter(DefaultOptions);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}